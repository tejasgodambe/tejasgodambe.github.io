<ul> 
<p> Taken from <a href="http://www.diveintopython3.net/your-first-python-program.html">http://www.diveintopython3.net/your-first-python-program.html</a> </p>
<li> Func_name.__doc__ gives the docstring of the function. 
We can see the docstring of a function like append or module like numpy. </li>
 
<li> Function args can NOT be named args followed by unnamed args. </li>

<li> dir(module/function/object) lists all attributes. Try dir(list) or dir(numpy). </li>
<li> Everything in Python is an object. Even functions are objects in Python.
This is important, so I’m going to repeat it in case you missed it the first few times: everything in Python is an object. Strings are objects. Lists are objects. Functions are objects. Classes are objects. Class instances are objects. Even modules are objects. </li>

<li> Every function returns. When there is no explicit return statement used, that function returns None. </li> 
<li> There are two kinds of functions/things. One is object’s, other one is built-in. </li> 
<li> The source code for built-in functions is not available as that is not written in Python, but is written in C. See this .. at http://www.diveintopython3.net/your-first-python-program.html#divingin
Actually, I lied; the truth is more complicated than that, because not all modules are stored as .py files. Some are built-in modules; they are actually baked right into Python itself. Built-in modules behave just like regular modules, but their Python source code is not available, because they are not written in Python! (Like Python itself, these built-in modules are written in C.) </li> 

<li> Python is a dynamically typed and strongly typed language. It’s not statically and loosely typed language. </li>
<li> Python searches for modules in directories listed in sys.path. </li>
<li> %reset in Python is the same as "clear all" for MATLAB. </li>
<li> %cpaste, %history </li>
<p> Taken from <a href="https://docs.python.org/3/reference/datamodel.html">https://docs.python.org/3/reference/datamodel.html</a> </p>
<li> __new__() creates an object and __init__() customizes the object </li>
<li> del x doesn’t directly call x.__del__() — the former decrements the reference count for x by one, and the latter is only called when x‘s reference count reaches zero. </li>

<p> Taken from <a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/</a> </p>
<li> Lists, strings, and tuples are sequences. Dictionaries, sets, and many other iterables are not sequences. </li>
<li> In the Python world, an iterable is any object that you can loop over with a for loop. </li>
<li> All iterables can be passed to the built-in iter function to get an iterator from them. </li> 
<li> The way iterators and iterables work is called the iterator protocol. List comprehensions, tuple unpacking, for loops, and all other forms of iteration rely on the iterator protocol. </li>
<li> I’ll explore iterators more in future articles. For now know that iterators are hiding behind the scenes of all iteration in Python. </li>
<p> Taken from <a href="https://docs.python.org/2/tutorial/datastructures.html">https://docs.python.org/2/tutorial/datastructures.html</a> </p>
<li> List comprehensions provide a concise way to create lists. </li>
<li> A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. </li> 
<p> Taken from <a href="http://stackoverflow.com/questions/1756096/understanding-generators-in-python">http://stackoverflow.com/questions/1756096/understanding-generators-in-python</a> </p> 
<li> A generator is simply a function which returns an iterator </li> 
<li> Using yield anywhere in a function makes it a generator. </li> 
<li> for loops call next in the background. </li> 
</ul> 
