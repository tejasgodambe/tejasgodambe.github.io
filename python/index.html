<ul> 
<p> <b> This tutorial on HDF5 with Python gives a good feel and is helpful </b> <a href="https://www.youtube.com/watch?v=y4DXr3Y10MM&list=PLea0WJq13cnB_ORdGzEkPlZEN20TSt6Lx&spfreload=10">HDF5 with Python</a></p> 

<p> Taken from <a href="http://www.diveintopython3.net/your-first-python-program.html">http://www.diveintopython3.net/your-first-python-program.html</a> </p>
<li> Func_name.__doc__ gives the docstring of the function. 
We can see the docstring of a function like append or module like numpy. </li>
 
<li> Function args can NOT be named args followed by unnamed args. </li>

<li> dir(module/function/object) lists all attributes. Try dir(list) or dir(numpy). </li>
<li> Everything in Python is an object. Even functions are objects in Python.
This is important, so I’m going to repeat it in case you missed it the first few times: everything in Python is an object. Strings are objects. Lists are objects. Functions are objects. Classes are objects. Class instances are objects. Even modules are objects. </li>

<li> Every function returns. When there is no explicit return statement used, that function returns None. </li> 
<li> There are two kinds of functions/things. One is object’s, other one is built-in. </li> 
<li> The source code for built-in functions is not available as that is not written in Python, but is written in C. See this .. at http://www.diveintopython3.net/your-first-python-program.html#divingin
Actually, I lied; the truth is more complicated than that, because not all modules are stored as .py files. Some are built-in modules; they are actually baked right into Python itself. Built-in modules behave just like regular modules, but their Python source code is not available, because they are not written in Python! (Like Python itself, these built-in modules are written in C.) </li> 

<li> Python is a dynamically typed and strongly typed language. It’s not statically and loosely typed language. </li>
<li> Python searches for modules in directories listed in sys.path. </li>
<li> %reset in Python is the same as "clear all" for MATLAB. </li>
<li> %cpaste, %history </li>
<p> Taken from <a href="https://docs.python.org/3/reference/datamodel.html">https://docs.python.org/3/reference/datamodel.html</a> </p>
<li> __new__() creates an object and __init__() customizes the object </li>
<li> del x doesn’t directly call x.__del__() — the former decrements the reference count for x by one, and the latter is only called when x‘s reference count reaches zero. </li>

<p> Taken from <a href="http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">http://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/</a> </p>
<li> Lists, strings, and tuples are sequences. Dictionaries, sets, and many other iterables are not sequences. </li>
<li> In the Python world, an iterable is any object that you can loop over with a for loop. </li>
<li> All iterables can be passed to the built-in iter function to get an iterator from them. </li> 
<li> The way iterators and iterables work is called the iterator protocol. List comprehensions, tuple unpacking, for loops, and all other forms of iteration rely on the iterator protocol. </li>
<li> I’ll explore iterators more in future articles. For now know that iterators are hiding behind the scenes of all iteration in Python. </li>
<p> Taken from <a href="https://docs.python.org/2/tutorial/datastructures.html">https://docs.python.org/2/tutorial/datastructures.html</a> </p>
<li> List comprehensions provide a concise way to create lists. </li>
<li> A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. </li> 
<p> Taken from <a href="http://stackoverflow.com/questions/1756096/understanding-generators-in-python">http://stackoverflow.com/questions/1756096/understanding-generators-in-python</a> </p> 
<li> A generator is simply a function which returns an iterator </li> 
<li> Using yield anywhere in a function makes it a generator. </li> 
<li> for loops call next in the background. </li> 
<li> Observe that a generator object is generated once, but its code is not run all at once. Only calls to next actually execute (part of) the code. Execution of the code in a generator stops once a yield statement has been reached, upon which it returns a value. The next call to next then causes execution to continue in the state in which the generator was left after the last yield. This is a fundamental difference with regular functions: those always start execution at the "top" and discard their state upon returning a value. </li>

<p> 
For first next(), execution starts at the top and continues till first yield statement is found. On second next(), the function code is not executed from the start but from the next statement after first yield all the way till the second yield statement. <br> 

def myGen(n): <br>
    yield n <br>
    print ('Hi') <br>
    yield n+1 <br>

g = myGen(6) <br>
next(g) <br>
 --6 <br>
next(g) <br>
 --Hi <br>
 --7 <br>
</p> 

<p> Taken from <a href="http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/">http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/</a> </p>

<li> class ClassName(object); object is a special variable in Python. </li>
<li> ClassName.methodName(instanceName) is equivalent to ClassName.methodName() </li>
<li> When we define a new class, a __str__() built-in function defined for all Python class gets attached to our class too. But, we can override any built-in function by defining a function in our class with the same name </li> 
<li> An instance of inherited class is an instance of both the inherited class and the base class </li>
<li> The __init__() method of the base class has to be explicitly called in the __init__() method of the derived class </li> 


<p> A class method defined outside of __init__() and after __init__() can be called/invoked within __init__(). This also reconciles 
and indicates that even if __init__() is defined as the second method, it will still get invoked with instantiation unlike other methods </p>  
<p> Parent class, Superclass and Heir class are the same. Child class or Subclass are the same </p>
<p> A convention is to use verbs for method names and nouns for attribute names </p> 
<p> The term "attribute" conveys what can a class be used for </p>

<p> 
<li> Taken from <a href="https://github.com/kaldi-asr/kaldi/blob/master/egs/wsj/s5/steps/nnet3/train_dnn.py">https://github.com/kaldi-asr/kaldi/blob/master/egs/wsj/s5/steps/nnet3/train_dnn.py</a> </li> 
sys.path.insert(0, 'steps') <br> 
import libs.nnet3.train.common <br>
</p> 

<p> 
<li> For run-time substitution of strings </li> 
'{0}_and_{1}'.format('apples','oranges') <br>
-- 'apples_and_oranges' <br> 
</p> 

</ul>
